#!/usr/bin/env python3

links = './links'

import argparse, sys, re, time
import concurrent.futures, multiprocessing
from subprocess import Popen, PIPE, TimeoutExpired
from xml.etree.ElementTree import Element, ElementTree

TIMEOUT = 15 # seconds before a test is timed out.

def FAIL(name, msg):
    return ('  error: %s' % name,'      (%s)' % msg)

def parse(stream):
    """Read test information separated by blank lines.  The first line
    is the test name; the second is the test code; the remaining lines
    are auxiliary options"""
    def tests():
        tests = []
        for line in stream.readlines():
            if not str.strip(line) and tests[-1]:
                yield tests
                tests = []
            else:
                tests.append(line)
        yield tests
    for test in tests():
        if not test:
            print('WARNING: empty test', file=sys.stderr)
        else:
            name = str.strip(test.pop(0))
            code = str.strip(test.pop(0))
            opts = dict([str.split(str.rstrip(line), ' : ', 1) for line in test])
            yield name, code, opts

# Lock not required for calling
def check_expected(name, item, got, expected, errors):
    """Check some data against an expected value or predicate.  If it
    matches, return True.  Otherwise, display an error and return
    False.
    """
    got, expected = got.rstrip(), expected.rstrip()
    if expected.startswith('@'):
        if not re.match(expected[1:], got, re.DOTALL):
            errors.append(FAIL(name, "Unexpected %s: expected `%s' (regex); got `%s'" %
                               (item, expected[1:], got)))
            return False
        else:
            return True
    elif expected != got:
        errors.append(FAIL(name, "Unexpected %s: expected `%s'; got `%s'" % (item, expected, got)))
        return False
    else:
        return True

def evaluate(name, code, config_file, stdout='', stderr='', exit = '0', env = None, filemode='', args='', ignore = None):
    arg_array = str.split(args)
    if config_file != None:
        for arg in arg_array:
            if arg.startswith("--config"):
                return ("error",
                        "Test \"%s\" comes with an args entry to specify the config file," % name +
                        " but a config file was also passed as a command-line argument to the test harness")

        arg_array += ["--config=" + config_file]

    if not filemode.startswith('true'):
        arg_array += ["-e"]

    proc = Popen([links] + arg_array + [code], stdout=PIPE, stderr=PIPE, universal_newlines=True, env=env)
    try:
        proc_stdout, proc_stderr = proc.communicate(timeout=TIMEOUT)
        passed = True
        errors = []

        passed &= check_expected(name, 'return code', str(proc.returncode), exit, errors)
        passed &= check_expected(name, 'stdout', proc_stdout, stdout, errors)
        passed &= check_expected(name, 'stderr', proc_stderr, stderr, errors)
        if passed:
            return "success", ""
        elif ignore != None:
            return "ignored", ""
        else:
            return "failure", "\n".join(msg + "\n" + detail for msg, detail in errors)
    except TimeoutExpired:
        proc.kill()
        return "error", "Timed out"

def main():
    args = argparse.ArgumentParser(description="Runs programs specified in a '.tests' file, and compares their results.")
    args.add_argument("filename", help="The path to the '.tests' file.")
    args.add_argument("config", nargs="?", help="An optional config file to use.")
    args.add_argument("--junit", help="The path to write a JUnit XML file to.")
    args = args.parse_args()

    cpus=multiprocessing.cpu_count()

    def work(task):
        name, code, opts = task
        start = time.time()
        status, message = evaluate(name, code, args.config, **opts)
        duration = time.time() - start
        return { "name": name, "time": duration, "status": status, "message": message }

    testsuite = Element("testsuite", { "name": args.filename })
    count, counts = 0, { "ignored": 0, "success": 0, "failure": 0, "error": 0 }
    start = time.time()
    with concurrent.futures.ThreadPoolExecutor(max_workers=cpus) as tp,\
         open(args.filename, "r") as handle:

        for result in tp.map(work, parse(handle)):
            status = result["status"]
            count += 1
            counts[status] += 1

            # Display the result to the console
            print("%8s: %s" % (status.upper(), result["name"]))
            if result["message"] != "":
                print(result["message"])

            # Build up an XML node
            testcase = Element("testcase", {
                "name": result["name"],
                "time": "%.03f" % result["time"],
                "classname": args.filename,
            })

            if status == "success":
                pass
            elif status == "ignored":
                testcase.append(Element("skipped"))
            else:
                testcase.append(Element(status, { "name": "Error", "message": result["message"] }))
            testsuite.append(testcase)

        # Wait for all jobs to finish
        tp.shutdown(wait=True)
    duration = time.time() - start

    testsuite.set("tests", str(count))
    testsuites = Element("testsuites", {
        "tests": str(count),
        "failures": str(counts["failure"]),
        "errors": str(counts["error"]),
        "time": "%.03f" % duration,
    })
    testsuites.append(testsuite)
    if args.junit is not None:
        ElementTree(testsuites).write(args.junit)

    counts["failure"] += counts["error"]
    print("{failure:d} failures (+{ignored:d} ignored)\n{success:d} successes\n".format(**counts))
    if counts["failure"] > 0:
        sys.exit(1)
    else:
        sys.exit(0)

if __name__ == '__main__':
    main()
